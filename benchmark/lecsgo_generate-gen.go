// Code generated by "go generate", DO NOT EDIT.
package ecs_benchmark

import (
	"sort"

	ecs "github.com/leopotam/go-ecs"
)

// NewLecsGOWorld returns new instance of LecsGOWorld.
func NewLecsGOWorld(entitiesCount uint32) *LecsGOWorld {
	return &LecsGOWorld{
		world: ecs.NewWorld(entitiesCount, []ecs.ComponentPool{
			newUIDesignPool(entitiesCount),
			newScriptPool(entitiesCount),
			newTransform2DPool(entitiesCount),
			newPhysics2DPool(entitiesCount),
		}, []ecs.Filter{
			*ecs.NewFilter([]uint16{2, 3}, []uint16{}, 512),
			*ecs.NewFilter([]uint16{0, 1}, []uint16{}, 512),
		}),
	}
}

// InternalWorld returns internal ecs.World instance.
func (w LecsGOWorld) InternalWorld() *ecs.World { return w.world }

// Destroy processes cleanup of data inside world.
func (w *LecsGOWorld) Destroy() { w.world.Destroy(); w.world = nil }

// NewEntity creates and returns new entity inside world.
func (w LecsGOWorld) NewEntity() ecs.Entity {
	return w.world.NewEntity()
}

// DelEntity removes entity from world if exists. All attached components will be removed first.
func (w LecsGOWorld) DelEntity(entity ecs.Entity) { w.world.DelEntity(entity) }

// PackEntity packs Entity to save outside from world.
func (w LecsGOWorld) PackEntity(entity ecs.Entity) ecs.PackedEntity {
	return w.world.PackEntity(entity)
}

// UnpackEntity tries to unpack data to Entity, returns unpacked entity and success of operation.
func (w LecsGOWorld) UnpackEntity(packedEntity ecs.PackedEntity) (ecs.Entity, bool) {
	return w.world.UnpackEntity(packedEntity)
}

type poolUIDesign []UIDesign

func newUIDesignPool(cap uint32) *poolUIDesign {
	var pool poolUIDesign = make([]UIDesign, 0, cap)
	return &pool
}

func (p *poolUIDesign) New() {
	*p = append(*p, UIDesign{})
}

func (p *poolUIDesign) Recycle(idx uint32) {
	(*p)[idx] = UIDesign{}
}

// SetUIDesign adds or returns exist UIDesign component on entity.
func (w LecsGOWorld) SetUIDesign(entity ecs.Entity) *UIDesign {
	entityData := &w.world.Entities[entity]
	pool := w.world.Pools[0].(*poolUIDesign)
	if !entityData.BitMask.Get(0) {
		entityData.BitMask.Set(0)
		maskIdx := sort.Search(len(entityData.Mask), func(i int) bool { return entityData.Mask[i] > 0 })
		entityData.Mask = append(entityData.Mask, 0)
		copy(entityData.Mask[maskIdx+1:], entityData.Mask[maskIdx:])
		entityData.Mask[maskIdx] = 0
		w.world.UpdateFilters(entity, 0, true)
	}
	return &(*pool)[entity]
}

// GetUIDesign returns exist UIDesign component on entity or nil.
func (w LecsGOWorld) GetUIDesign(entity ecs.Entity) *UIDesign {
	if !w.world.Entities[entity].BitMask.Get(0) {
		return nil
	}
	return &(*w.world.Pools[0].(*poolUIDesign))[entity]
}

// GetUIDesignUnsafe returns exist UIDesign component on entity or nil.
func (w LecsGOWorld) GetUIDesignUnsafe(entity ecs.Entity) *UIDesign {
	return &(*w.world.Pools[0].(*poolUIDesign))[entity]
}

// DelUIDesign removes UIDesign component or do nothing.
// If entity is empty after removing - it will be destroyed automatically.
func (w LecsGOWorld) DelUIDesign(entity ecs.Entity) {
	entityData := &w.world.Entities[entity]
	if entityData.BitMask.Get(0) {
		if len(entityData.Mask) > 1 {
			w.world.UpdateFilters(entity, 0, false)
			w.world.Pools[0].(*poolUIDesign).Recycle(entity)
			maskLen := len(entityData.Mask)
			//lint:ignore SA4003 ignore bugs in other packages
			maskIdx := sort.Search(maskLen, func(i int) bool { return entityData.Mask[i] >= 0 })
			copy(entityData.Mask[maskIdx:], entityData.Mask[maskIdx+1:])
			entityData.Mask = entityData.Mask[:maskLen-1]
			entityData.BitMask.Unset(0)
		} else {
			w.DelEntity(entity)
		}
	}
}

type poolScript []Script

func newScriptPool(cap uint32) *poolScript {
	var pool poolScript = make([]Script, 0, cap)
	return &pool
}

func (p *poolScript) New() {
	*p = append(*p, Script{})
}

func (p *poolScript) Recycle(idx uint32) {
	(*p)[idx] = Script{}
}

// SetScript adds or returns exist Script component on entity.
func (w LecsGOWorld) SetScript(entity ecs.Entity) *Script {
	entityData := &w.world.Entities[entity]
	pool := w.world.Pools[1].(*poolScript)
	if !entityData.BitMask.Get(1) {
		entityData.BitMask.Set(1)
		maskIdx := sort.Search(len(entityData.Mask), func(i int) bool { return entityData.Mask[i] > 1 })
		entityData.Mask = append(entityData.Mask, 0)
		copy(entityData.Mask[maskIdx+1:], entityData.Mask[maskIdx:])
		entityData.Mask[maskIdx] = 1
		w.world.UpdateFilters(entity, 1, true)
	}
	return &(*pool)[entity]
}

// GetScript returns exist Script component on entity or nil.
func (w LecsGOWorld) GetScript(entity ecs.Entity) *Script {
	if !w.world.Entities[entity].BitMask.Get(1) {
		return nil
	}
	return &(*w.world.Pools[1].(*poolScript))[entity]
}

// GetScriptUnsafe returns exist Script component on entity or nil.
func (w LecsGOWorld) GetScriptUnsafe(entity ecs.Entity) *Script {
	return &(*w.world.Pools[1].(*poolScript))[entity]
}

// DelScript removes Script component or do nothing.
// If entity is empty after removing - it will be destroyed automatically.
func (w LecsGOWorld) DelScript(entity ecs.Entity) {
	entityData := &w.world.Entities[entity]
	if entityData.BitMask.Get(1) {
		if len(entityData.Mask) > 1 {
			w.world.UpdateFilters(entity, 1, false)
			w.world.Pools[1].(*poolScript).Recycle(entity)
			maskLen := len(entityData.Mask)
			maskIdx := sort.Search(maskLen, func(i int) bool { return entityData.Mask[i] >= 1 })
			copy(entityData.Mask[maskIdx:], entityData.Mask[maskIdx+1:])
			entityData.Mask = entityData.Mask[:maskLen-1]
			entityData.BitMask.Unset(1)
		} else {
			w.DelEntity(entity)
		}
	}
}

type poolTransform2D []Transform2D

func newTransform2DPool(cap uint32) *poolTransform2D {
	var pool poolTransform2D = make([]Transform2D, 0, cap)
	return &pool
}

func (p *poolTransform2D) New() {
	*p = append(*p, Transform2D{})
}

func (p *poolTransform2D) Recycle(idx uint32) {
	(*p)[idx] = Transform2D{}
}

// SetTransform2D adds or returns exist Transform2D component on entity.
func (w LecsGOWorld) SetTransform2D(entity ecs.Entity) *Transform2D {
	entityData := &w.world.Entities[entity]
	pool := w.world.Pools[2].(*poolTransform2D)
	if !entityData.BitMask.Get(2) {
		entityData.BitMask.Set(2)
		maskIdx := sort.Search(len(entityData.Mask), func(i int) bool { return entityData.Mask[i] > 2 })
		entityData.Mask = append(entityData.Mask, 0)
		copy(entityData.Mask[maskIdx+1:], entityData.Mask[maskIdx:])
		entityData.Mask[maskIdx] = 2
		w.world.UpdateFilters(entity, 2, true)
	}
	return &(*pool)[entity]
}

// GetTransform2D returns exist Transform2D component on entity or nil.
func (w LecsGOWorld) GetTransform2D(entity ecs.Entity) *Transform2D {
	if !w.world.Entities[entity].BitMask.Get(2) {
		return nil
	}
	return &(*w.world.Pools[2].(*poolTransform2D))[entity]
}

// GetTransform2DUnsafe returns exist Transform2D component on entity or nil.
func (w LecsGOWorld) GetTransform2DUnsafe(entity ecs.Entity) *Transform2D {
	return &(*w.world.Pools[2].(*poolTransform2D))[entity]
}

// DelTransform2D removes Transform2D component or do nothing.
// If entity is empty after removing - it will be destroyed automatically.
func (w LecsGOWorld) DelTransform2D(entity ecs.Entity) {
	entityData := &w.world.Entities[entity]
	if entityData.BitMask.Get(2) {
		if len(entityData.Mask) > 1 {
			w.world.UpdateFilters(entity, 2, false)
			w.world.Pools[2].(*poolTransform2D).Recycle(entity)
			maskLen := len(entityData.Mask)
			maskIdx := sort.Search(maskLen, func(i int) bool { return entityData.Mask[i] >= 2 })
			copy(entityData.Mask[maskIdx:], entityData.Mask[maskIdx+1:])
			entityData.Mask = entityData.Mask[:maskLen-1]
			entityData.BitMask.Unset(2)
		} else {
			w.DelEntity(entity)
		}
	}
}

type poolPhysics2D []Physics2D

func newPhysics2DPool(cap uint32) *poolPhysics2D {
	var pool poolPhysics2D = make([]Physics2D, 0, cap)
	return &pool
}

func (p *poolPhysics2D) New() {
	*p = append(*p, Physics2D{})
}

func (p *poolPhysics2D) Recycle(idx uint32) {
	(*p)[idx] = Physics2D{}
}

// SetPhysics2D adds or returns exist Physics2D component on entity.
func (w LecsGOWorld) SetPhysics2D(entity ecs.Entity) *Physics2D {
	entityData := &w.world.Entities[entity]
	pool := w.world.Pools[3].(*poolPhysics2D)
	if !entityData.BitMask.Get(3) {
		entityData.BitMask.Set(3)
		maskIdx := sort.Search(len(entityData.Mask), func(i int) bool { return entityData.Mask[i] > 3 })
		entityData.Mask = append(entityData.Mask, 0)
		copy(entityData.Mask[maskIdx+1:], entityData.Mask[maskIdx:])
		entityData.Mask[maskIdx] = 3
		w.world.UpdateFilters(entity, 3, true)
	}
	return &(*pool)[entity]
}

// GetPhysics2D returns exist Physics2D component on entity or nil.
func (w LecsGOWorld) GetPhysics2D(entity ecs.Entity) *Physics2D {
	if !w.world.Entities[entity].BitMask.Get(3) {
		return nil
	}
	return &(*w.world.Pools[3].(*poolPhysics2D))[entity]
}

// GetPhysics2DUnsafe returns exist Physics2D component on entity or nil.
func (w LecsGOWorld) GetPhysics2DUnsafe(entity ecs.Entity) *Physics2D {
	return &(*w.world.Pools[3].(*poolPhysics2D))[entity]
}

// DelPhysics2D removes Physics2D component or do nothing.
// If entity is empty after removing - it will be destroyed automatically.
func (w LecsGOWorld) DelPhysics2D(entity ecs.Entity) {
	entityData := &w.world.Entities[entity]
	if entityData.BitMask.Get(3) {
		if len(entityData.Mask) > 1 {
			w.world.UpdateFilters(entity, 3, false)
			w.world.Pools[3].(*poolPhysics2D).Recycle(entity)
			maskLen := len(entityData.Mask)
			maskIdx := sort.Search(maskLen, func(i int) bool { return entityData.Mask[i] >= 3 })
			copy(entityData.Mask[maskIdx:], entityData.Mask[maskIdx+1:])
			entityData.Mask = entityData.Mask[:maskLen-1]
			entityData.BitMask.Unset(3)
		} else {
			w.DelEntity(entity)
		}
	}
}

// WithPhysTransform returns user filter.
func (w LecsGOWorld) WithPhysTransform() *ecs.Filter {
	return w.world.Filter(0)
}

// WithDesignScript returns user filter.
func (w LecsGOWorld) WithDesignScript() *ecs.Filter {
	return w.world.Filter(1)
}
